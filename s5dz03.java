/* Задание № 3
Реализовать алгоритм пирамидальной сортировки (HeapSort). 
 */

import java.util.Arrays;

public class s5dz03 {

  private static int Left(int i) { // вернуть левого потомка `A[i]`
    return (2 * i + 1);
  }

  private static int Right(int i) { // вернуть правого потомка `A[i]`
    return (2 * i + 2);
  }

  private static void Swap(int[] array, int i, int j) { // замена двух индексов в массиве
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }

  // Рекурсивный алгоритм heapify-down, если узел с индексом `i` и два его прямых потомка нарушают свойство кучи
  private static void heapify(int[] array, int i, int size) {
    int left = Left(i); // получить левый и правый потомки узла с индексом `i`
    int right = Right(i);
    int largest = i;

    if (left < size && array[left] > array[i]) { // находим max между `A[i]` с его левым и правым дочерними элементами
      largest = left;
    }
    if (right < size && array[right] > array[largest]) {
      largest = right;
    }

    // поменяться местами с элементом, имеющим большее значение и сортировка для дочернего элемента
    if (largest != i) {
      Swap(array, i, largest);
      heapify(array, largest, size);
    }
  }

  public static int pop(int[] array, int size) { // Удаление элемента с наивысшим приоритетом (присутствует в корне)
    if (size <= 0) {  // если в куче нет элементов
      return -1;
    }

    int top = array[0];
    array[0] = array[size - 1];  // заменяем корень кучи последним элементом массива
    heapify(array, 0, size - 1);  // heapify-down на корневом узле

    return top;
  }

  // Функция для выполнения пирамидальной сортировки массива `A` размера `n`
  public static void heapsort(int[] array) {
   
    int len = array.length;

    // Build-heap: вызывать heapify, начиная с последнего внутреннего узла до корневого узла
    int i = (len - 2) / 2;
    while (i >= 0) {
      heapify(array, i--, len);
    }
    
    while (len > 0) {  // несколько раз извлекаем из кучи, пока она не станет пустой
      array[len - 1] = pop(array, len);
      len--;
    }
  }

 
  public static void main(String[] args) {
    int[] inputArray = { 6, 4, 7, 1, 9, -2 };

    heapsort(inputArray);    // выполняем иерархическую сортировку массива
    System.out.println(Arrays.toString(inputArray));
  }
}
/*
 * Достоинства метода пирамидальной сортировки (HeapSort).
 * 
 * 
 * Имеет доказанную оценку худшего случая O(n\cdot\log n).
 * Сортирует на месте, то есть требует всего O(1) дополнительной памяти (если
 * дерево организовывать так, как показано выше).
 * 
 * Недостатки пирамидальной сортировки (HeapSort).
 * 
 * Сложен в реализации.
 * Неустойчив — для обеспечения устойчивости нужно расширять ключ.
 * На почти отсортированных массивах работает столь же долго, как и на
 * хаотических данных.
 * На одном шаге выборку приходится делать хаотично по всей длине массива —
 * поэтому алгоритм плохо сочетается с кэшированием и подкачкой памяти.
 * Методу требуется «мгновенный» прямой доступ; не работает на связанных списках
 * и других структурах памяти последовательного доступа.
 * 
 * Сортировка слиянием при расходе памяти O(n) быстрее (O(n\cdot\log n) с
 * меньшей константой) и не подвержена деградации на неудачных данных.
 * 
 * Из-за сложности алгоритма выигрыш получается только на больших n. На
 * небольших n (до нескольких тысяч) быстрее сортировка Шелла.
 */